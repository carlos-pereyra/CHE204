#include <cstdlib>    // c++
#include <cstdio>     // c++
#include <omp.h>
#include <vector>     // c++
#include <algorithm>  // c++
#include <iostream>   // c++
#include <iomanip>    // c++
#include <fstream>    // c++
#include <math.h>
#include <mpi.h>
#include <algorithm>    // std::sort
#include <vector>       // std::vector

#define DBG 0
#define PNT 0

#ifdef __APPLE__
#include <Accelerate/Accelerate.h>
#else
#include <cblas.h>
#endif

// (on OS X) compile this code with,
//
//      g++ -Xpreprocessor -fopenmp -lomp -framework Accelerate -o test main.cpp
//
//      ./test
//

using namespace std;

// INITIALIZATION
double* ReadInput(string filename, long nlines, double* mat);
double* ComputeKij(const long n, double* XYZi, double* Kij);

// IO
void PrintMatrix(string desc, int m, int n, double* a, int lda );
void WriteResults(long n, double* ei, double* vi, double* ei2, double* vi2 );

// HESSIAN
double* ComputeHessian(long n, double* x, double* hij);

#define NATOMS 32    // natoms matches the number of atoms in .xyz file
#define NDIM 3

#define N NATOMS*NDIM
#define LDA N

#define NRUNS 1100

#define ALPHA 0.01
#define STRIDE 1
#define NSHOW 5

int main(int argc, char** argv) {
    /*
     * VECTOR & MATRICES
     */
    int mem =0;
    double *Xi  = (double *) malloc(sizeof(double)*N); mem += sizeof(double)*N;     // N x 1
    double *Yi  = (double *) malloc(sizeof(double)*N); mem += sizeof(double)*N;     // N x 1
    
    double *Kij = (double *) malloc(sizeof(double)*N*N); mem += sizeof(double)*N*N; // N x N
    double *Kij2= (double *) malloc(sizeof(double)*N*N); mem += sizeof(double)*N*N; // N x N
    
    double* Ei  = (double *) malloc(sizeof(double)*N); mem += sizeof(double)*N;     // N x 1
    double* Vi  = (double *) malloc(sizeof(double)*3*N); mem += sizeof(double)*3*N; // N x 3
    
    double* Ei2 = (double *) malloc(sizeof(double)*N); mem += sizeof(double)*N;     // N x 1
    double* Vi2 = (double *) malloc(sizeof(double)*3*N); mem += sizeof(double)*3*N; // N x 3

    /* read xyz positions */
    ReadInput("coordinates/Final_Coords.xyz", NATOMS, Xi);
    if(1) PrintMatrix("Xi", 1, 10, Xi, 1);

    /*
     * COMPUTE HESSIAN
     *          Kij = d''V / dxi dxj
     */
    ComputeHessian(N, Xi, Kij);
    //PrintMatrix("Hessian", N, N, Kij, N);

    /*
     * FIND EIGENVALUES OF HESSIAN
     */
    char JOBZ='V'; char UPLO='U'; int N_INT = N; int LDA_INT = LDA; int LWORK = 3*N - 1; int INFO;
    LWORK = -1;
    dsyev_(&JOBZ, &UPLO, &N_INT, Kij, &LDA_INT, Ei, Vi, &LWORK, &INFO);
    LWORK = 3*N - 1;
    dsyev_(&JOBZ, &UPLO, &N_INT, Kij, &LDA_INT, Ei, Vi, &LWORK, &INFO);

    /* read xyz positions */
    ReadInput("coordinates/Optimized_Argon_Cluster_Morse.xyz", NATOMS, Yi);
    //PrintMatrix("Yi", 1, 10, Yi, 1);
    ComputeHessian(N, Yi, Kij2);
    dsyev_(&JOBZ, &UPLO, &N_INT, Kij2, &LDA_INT, Ei2, Vi2, &LWORK, &INFO);
    
    /*
     * PRINT / WRITE RESULTS
     */
    WriteResults(N, Ei, Vi, Ei2, Vi2);
    PrintMatrix("Eigenvalues", 1, N, Ei, 1);
    PrintMatrix("Eigenvalues Optimized", 1, N, Ei2, 1);

    /*
     * FREE MEMORY
     */
    printf("\nfree %lf (kB)\n", mem / 1000.);

    free(Xi); free(Kij); free(Ei); free(Vi);
    free(Yi); free(Kij2);free(Ei2);free(Vi2);
}

//
// INITIALIZATION
//

double* ReadInput(string filename, long nlines, double *mat) {
    // read in positions from .xyz file
    ifstream infile(filename);
    string elem, line;
    double x, y, z;
    long counter, natoms;
    
    if(!infile.is_open()) exit(1);
    
    counter=0;
    std::getline(infile, line); std::istringstream iss(line); iss >> natoms; // line 1
    std::cout << "natoms = " << natoms << "\n"; 
    std::getline(infile, line);  // line 2
    while(std::getline(infile, line) || counter<nlines) {
        // read x y z coords
        std::istringstream iss(line);

        if (iss >> elem >> x >> y >> z) cout << counter << " elem = " << elem << " x = " << x << " y = " << y << " z " << z << "\n";

        mat[3*counter + 0] = x;
        mat[3*counter + 1] = y;
        mat[3*counter + 2] = z;

        counter++;
    }
    infile.close();
    return mat;
}

//
// IO
//

void PrintMatrix(string desc, int m, int n, double* a, int lda ) {
        int i, j, c = 0;
        std::cout << "\n" << desc << "\n";
        for( i = 0; i < m; i++ ) {
                for( j = 0; j < n; j++ ) {
                    printf( "%d -> %6.6f\n", c,a[i+j*lda] ); c++;
                }
                printf( "\n" );
        }
}

void WriteResults(long n, double* ei, double* vi, double* ei2, double* vi2) {
    // write first set of eigen modes and second set of eigen values
    // first set corresponds to coordinates I generated.
    // second set corresponds to coordinates generated by professor.
    string filename = "data/output.dat";
    ofstream file;
    
    // open new file
    file.open(filename, std::fstream::out);
    file << left << setw(20) << "# eig-val-1";
    file << left << setw(20) << "eig-vec-1";
    file << left << setw(20) << "eig-val-2";
    file << "eig-vec-2" << "\n";

    // write results to file
    for(int i = 0; i < n; i++) {
        //file << std::scientific;
        file << left << setw(20) << ei[i];
        file << left << setw(20) << sqrt(pow(vi[i*3 + 0], 2) + pow(vi[i*3 + 1], 2) + pow(vi[i*3 + 2], 2));
        file << left << setw(20) << ei2[i];
        file << sqrt(pow(vi2[i*3 + 0], 2) + pow(vi2[i*3 + 1], 2) + pow(vi2[i*3 + 2], 2)) << "\n";
    }
    file.close();
}

//
// HESSIAN
//
double MorseForce(double xi, double xj, double rij) {
    //
    if(DBG) printf("\nMorseForce()\n");
    double d = 1; double a = 1; double ro = 3.5;
    double xij = xi - xj;
    double f = 2*d*a * ( exp(-2*a*(rij-ro)) - exp(-a*(rij-ro)) ) * xij / rij;
    return f;
}

double* ComputeHessian(long n, double* x, double* hij) {
    /* COMPUTE N x N REAL HESSIAN
     *
     * finite central difference method of second order derivative requires differential distance
     *
     * CENTRAL SECOND DERIVATIVE
     *
     *          Kij = (-Fi(xi+h) - -Fi(xi-h)) / dx
     * 
     */
    long i, j, k; long count = 0;
    double xi, xj;
    double dx = 0.01;
    double xij, yij, zij;
    double rij_plus;
    double rij_minus;
    double f1, f2;
    /*
     * F(x + dx) = f1 (force)
     * F(x - dx) = f2 (force)
     */
    long natom = n / 3;
    for(i = 0; i < n; i++) {
        for(j = 0; j < natom; j++) {
            double xij       = x[3*i + 0] - x[3*j + 0];
            double yij       = x[3*i + 1] - x[3*j + 1];
            double zij       = x[3*i + 2] - x[3*j + 2];
            double rij_plus  = sqrt(pow(xij+dx, 2) + pow(yij+dx, 2) + pow(zij+dx, 2));
            double rij_minus = sqrt(pow(xij-dx, 2) + pow(yij-dx, 2) + pow(zij-dx, 2));
            for(k = 0; k < 3; k++) {
                xi = x[3*i + k];
                xj = x[3*j + k];
                f1 = MorseForce(xi+dx, xj, rij_plus);
                f2 = MorseForce(xi-dx, xj, rij_minus);
                hij[i*n + j*3 + k] = ( -1*f1 - -1*f2 ) / dx;
                //printf("i = %ld j = %ld k = %ld xi = %lf xj = %lf f =%lf\n", i, j, k, xi, xj, hij[i*n + j*3 + k]);
                //count++;
            }
        }
    }
    return hij;
}
